#INCLUDE 'Protheus.ch'
#include 'topconn.ch'

#DEFINE USADO CHR(0)+CHR(0)+CHR(1)

/*/{Protheus.doc} ResTela
// Função que encapsula a exibição da tela de reservas
@author andre.oliveira
@since 13/09/2019
@version 1.0
@param lEfetiva, logical, Indica se é PV (.T.) ou proposta (.F.)
@type function
/*/
User Function ResTela(lEfetiva,nOpc,lAutoma)
	Local lRet := .T.
	Local oModel := FWModelActive()

	If Select("BKPZP2") > 0 .Or. IsBlind() .Or. Iif(lEfetiva,aCols[n,Len(aHeader)+1],oModel:GetModel('ADZPRODUTO'):IsDeleted())
		Return lRet
	EndIf

	If lEfetiva
		lRet := ResShow(	M->C5_NUM,;
		aCols[n,GDFieldPos("C6_ITEM")],;
		aCols[n,GDFieldPos("C6_PRODUTO")],;
		aCols[n,GDFieldPos("C6_DESCRI")],;
		aCols[n,GDFieldPos("C6_LOCAL")],;
		aCols[n,GDFieldPos("C6_QTDVEN")],;
		lEfetiva,;
		nOpc,;
		lAutoma	)
	Else
		SB1->(dbSetOrder(1))
		SB1->(MsSeek(xFilial("SB1")+FWFldGet("ADZ_PRODUT")))

		lRet := ResShow(	FWFldGet("ADY_PROPOS"),;
		FWFldGet("ADZ_ITEM"),;
		SB1->B1_COD,;
		FWFldGet("ADZ_DESCRI"),;
		RetFldProd(SB1->B1_COD,"B1_LOCPAD"),;
		FWFldGet("ADZ_QTDVEN"),;
		lEfetiva,;
		nOpc,;
		lAutoma	)
	EndIf

Return lRet

/*/{Protheus.doc} ResShow
// Funcao que exibe a tela de reservas
@author andre.oliveira
@since 13/09/2019
@version 1.0
@param cNumPV, characters, Número do pedido de venda/proposta
@param cItem, characters, Item do pedido de venda
@param cProduto, characters, Código do produto
@param cDescri, characters, Descrição do produto
@param cLocal, characters, Local para faturamento
@param nQtdPed, numeric, Quantidade no item do pedido/proposta
@param lEfetiva, logical, Indica se é PV (.T.) ou proposta (.F.)
@param nOpc, numeric, Indicador da operação executada
@type function
/*/
Static Function ResShow(cNumPV,cItem,cProduto,cDescri,cLocal,nQtdPed,lEfetiva,nOpc,lAutoma)
	Local lRet		:= .T.
	Local lOk		:= .F.
	Local lAltera	:= .F.
	Local oDlg		:= NIL
	Local oGetD		:= NIL
	Local oSize		:= NIL
	Local cSQLComm	:= ""
	Local aButtons	:= {}
	Local aHeadBkp	:= {}
	Local aColsBkp	:= {}
	Local nNBkp		:= 0
	Local nX		:= 0
	Local dDataLin	:= dDataBase + SuperGetMV("FS_DTADIC",.F.,60)
	Local bBkp		:= SetKey(VK_F6,NIL)
	Local bManut	:= {|| U_ResManut(cNumPV,cItem,cProduto,cLocal,CalQtdSRes(cNumPV,cItem,nQtdPed,lEfetiva),lEfetiva,@oGetD,.F.)}

	Default lAutoma := .T.

	If Type('aHeader') == "A"
		aHeadBKP := aClone(aHeader)
	EndIf
	If Type('aCols') == "A"
		aColsBKP := aClone(aCols)
	EndIf
	If Type('n') == "N"
		nNBkp := n
	EndIf

	aHeader := {}
	aCols := {}
	n := 1

	If nOpc == 3 .Or. nOpc == 4
		If !lAutoma
			SetKey(VK_F6,bManut)
			aAdd(aButtons,{"HISTORIC",bManut,"Editar reservas <F6>","Editar reservas <F6>",{|| .T.}})
		EndIf

		BeginSQL Alias "BKPZP2"
			SELECT *
			FROM %Table:ZP2%
			WHERE %NotDel% AND
			ZP2_FILIAL = %xFilial:ZP2% AND
			ZP2_NUMPV = %Exp:cNumPV% AND
			ZP2_ITEMPV = %Exp:cItem% AND
			ZP2_FLAGEF = %Exp:Iif(lEfetiva,"T","F")%
		EndSQL
		TCSetField("BKPZP2","ZP2_DENTPC","D",8,0)
		TCSetField("BKPZP2","ZP2_DENTPV","D",8,0)
		TCSetField("BKPZP2","ZP2_FLAGEX","L",1,0)
		TCSetField("BKPZP2","ZP2_FLAGEF","L",1,0)
		TCSetField("BKPZP2","ZP2_FLAGQT","L",1,0)
		TCSetField("BKPZP2","ZP2_FLAGC0","L",1,0)
		lAltera := .T.
	ElseIf nOpc # 5
		U_ResLoad2(cNumPV,lEfetiva)
	EndIf

	nQtdEnt := GetAdvFVal("SC6","C6_QTDENT",xFilial("SC6")+cProduto+cNumPv+cItem,2)

	If !lAutoma
		aAdd(aButtons,{"HISTORIC",{|| Legenda()},"Legenda de status","Legenda",{|| .T.}})

		FillGetRes(cNumPV,cItem,lEfetiva,@oGetD)

		DEFINE MSDIALOG oDlg TITLE "Reservas" From 0,0 to 600,900 of oMainWnd PIXEL

		oSize := FwDefSize():New(.T.)
		oSize:AddObject("CIMA",100,10,.F.,.F.,.T.) 
		oSize:AddObject("BAIXO",100,90,.F.,.F.,.T.)
		oSize:lProp := .T. 
		oSize:aMargins := {3,3,3,3} 
		oSize:Process()

		@oSize:GetDimension("CIMA","LININI"),oSize:GetDimension("CIMA","COLINI") SAY "Item: " +cItem +" | Produto: " +AllTrim(cProduto) +" - " +AllTrim(cDescri) OF oDlg PIXEL
		oGetD := MSGetDados():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),280,450,If(lAltera,4,2),'AllwaysTrue','AllwaysTrue','',.T.,,,,,'AllwaysTrue',,,'AllwaysFalse',oDlg)
		oGetD:SetEditLine(.F.)
		@oSize:GetDimension("BAIXO","LININI")+240,oSize:GetDimension("BAIXO","COLINI") SAY "Quantidade do item: " +Transform(nQtdPed,PesqPict("SB2","B2_QATU")) OF oDlg PIXEL
		@oSize:GetDimension("BAIXO","LININI")+240,oSize:GetDimension("BAIXO","COLINI")+150 SAY "Quantidade reservada: " +Transform(nQtdPed - CalQtdSRes(cNumPV,cItem,nQtdPed,lEfetiva),PesqPict("SB2","B2_QATU")) OF oDlg PIXEL

		@oSize:GetDimension("BAIXO","LININI")+240,oSize:GetDimension("BAIXO","COLINI")+300 SAY "Quantidade já entregue: " +Transform(nQtdEnt,PesqPict("SB2","B2_QATU")) OF oDlg PIXEL

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,	{|| lOK := .T., IIf(TudoOK(.T.,cNumPV,cItem,cProduto,cLocal,nQtdPed,lEfetiva,@oGetD,aHeadBKP,@aColsBKP,nNBkp,@lRet),oDlg:End(),NIL)},;
		{|| lOK := .F., Iif(TudoOK(.F.,cNumPV,cItem,cProduto,cLocal,nQtdPed,lEfetiva,@oGetD,aHeadBKP,@aColsBKP,nNBkp,@lRet),oDlg:End(),NIL)},.F.,aButtons,,,.F.,.F.,.F.,,.F.)
	Else
		U_ResManut(cNumPV,cItem,cProduto,cLocal,CalQtdSRes(cNumPV,cItem,nQtdPed,lEfetiva),lEfetiva,@oGetD,.T.)
		lOK := .T.
	EndIf

	If nOpc == 3 .Or. nOpc == 4
		If !lOk .Or. !lRet
			U_ResLimZP("ZP2",cNumPV,cItem,lEfetiva)

			While !BKPZP2->(EOF())
				RecLock("ZP2",.T.)
				For nX := 1 To ZP2->(FCount())
					ZP2->(FieldPut(nX,BKPZP2->&(ZP2->(FieldName(nX)))))
				Next nX
				ZP2->(MsUnLock())

				BKPZP2->(dbSkip())
			End
		Else
			//-- Atualiza data de entrega digitada pelo usuário
			For nX := 1 To Len(aCols)
				cSQLComm := "UPDATE " +RetSQLName("ZP2") +" SET ZP2_DENTPV = '" +DToS(aCols[nX,GDFieldPos("ZP2_DENTPV")]) +"' WHERE "
				cSQLComm += "D_E_L_E_T_ = ' ' AND ZP2_FILIAL = '" +xFilial("ZP2") +"' AND "
				cSQLComm += "ZP2_NUMPV = '" +cNumPV +"' AND ZP2_ITEMPV = '" +cItem +"' AND "
				cSQLComm += "ZP2_NUMPC = '" +aCols[nX,GDFieldPos("ZP2_NUMPC")] +"' AND ZP2_ITEMPC = '" +aCols[nX,GDFieldPos("ZP2_ITEMPC")] +"' AND "
				cSQLComm += "ZP2_FLAGEF = '" +Iif(lEfetiva,"T","F") +"'"
				If TCSQLExec(cSQLComm) < 0
					Aviso("Erro fatal na função ResShow",TCSQLError(),{"OK"},3)
					Final("Erro fatal na função ResShow.")
				EndIf
			Next nX

			//-- Atualiza data de entrega no PV com a maior data (qdo 100% reservado) ou com FS_DTADIC (quando sem reserva)
			aSort(aCols,,,{| x,y | x[GDFieldPos("ZP2_DENTPV")] > y[GDFieldPos("ZP2_DENTPV")]})
			If Empty(CalQtdSRes(cNumPV,cItem,nQtdPed,lEfetiva))
				dDataLin := aCols[1,GDFieldPos("ZP2_DENTPV")]
			EndIf
			If lEfetiva
				aColsBkp[nNBkp,GDFieldPos("C6_ENTREG",aHeadBkp)] := dDataLin
			ElseIf ADZ->(FieldPos("ADZ_XDTENT")) > 0
				FWFldPut("ADZ_XDTENT",dDataLin)
			EndIf
		EndIf
		BKPZP2->(dbCloseArea())
	ElseIf nOpc # 5
		U_ResLimZP("ZP2",cNumPV,,lEfetiva)
	EndIf

	ZP2->(dbClearFilter())

	If !Empty(aHeadBKP)
		aHeader := aClone(aHeadBKP)
	EndIf
	If !Empty(aColsBKP)
		aCols := aClone(aColsBKP)
	EndIf
	If !Empty(nNBkp)
		n := nNBkp
	EndIf

	SetKey(VK_F6,bBkp)

Return lRet

/*/{Protheus.doc} ResManut
// Função responsável por avaliar saldos disponiveis e apresentar tela para escolha do usuário.
@author andre.oliveira
@since 09/09/2019
@version 1.0
@param cNumPV, characters, Código do pedido de venda
@param cItem, characters, Código do item do pedido de venda
@param cProduto, characters, Código do produto no item do pedido de venda
@param cLocal, characters, Armazem/local no item do pedido de venda
@param nQtde, numeric, Quantidade no item do pedido de venda ainda sem reserva
@type function
/*/
User Function ResManut(cNumPV,cItem,cProduto,cLocal,nQtde,lEfetiva,oGetD,lAutoma)
	Local lOK		:= .T.
	Local nSldDisp 	:= 0
	Local nX		:= 0
	Local aSaldos	:= {}
	Local aButtons	:= {}
	Local oList		:= NIL
	Local oSize		:= NIL
	Local oDlg		:= NIL
	Local oOk      	:= LoadBitmap(GetResources(),"LBOK")
	Local oNo       := LoadBitmap(GetResources(),"LBNO")
	Local bBkp		:= NIL
	Local bDetalhe	:= {|| VisualDet(cProduto,aSaldos[oList:nAt,6])}

	If !lAutoma
		bBkp := SetKey(VK_F6,bDetalhe)
		aAdd(aButtons,{"HISTORIC",bDetalhe,"Visualizar detalhe <F6>","Detalhe <F6>",{|| .T.}})
	EndIf

	SB2->(dbSetOrder(1))
	SB2->(MsSeek(xFilial("SB2")+cProduto+cLocal))
	nSldDisp := SaldoSB2(.T.) +RetSC0Item(cNumPV,cItem) -RetSC0NGrv(cNumPV,cItem,cProduto,cLocal,lEfetiva)

	aAdd(aSaldos,{.F.,'ESTOQUE',0,nSldDisp,dDataBase,Space(Len(SC7->C7_NUM)),Space(Len(SC7->C7_ITEM))})

	BeginSQL Alias "SC7TMP"
		SELECT SC7.C7_NUM,
		SC7.C7_ITEM,
		SC7.C7_DATPRF,
		SC7.C7_QUANT - SC7.C7_QUJE - 
		
			(SELECT COALESCE(SUM(ZP1_QTDE),0)
			FROM %Table:ZP1% ZP1
			WHERE ZP1.%NotDel% AND
				ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
				ZP1.ZP1_NUMPC = SC7.C7_NUM AND
				ZP1.ZP1_ITEMPC = SC7.C7_ITEM AND
				ZP1.ZP1_FLAGEF = 'T' AND
				ZP1.ZP1_FLAGC0 = 'F' AND
				NOT EXISTS (SELECT R_E_C_N_O_ 
							FROM %Table:ZP2% 
							WHERE ZP2_FILIAL||ZP2_NUMPV||ZP2_ITEMPV = ZP1.ZP1_FILIAL||ZP1.ZP1_NUMPV||ZP1.ZP1_ITEMPV)) -
			
			(SELECT COALESCE(SUM(ZP2_QTDE),0)
			FROM %Table:ZP2% ZP2
			WHERE ZP2.%NotDel% AND
				ZP2.ZP2_FILIAL = %xFilial:ZP2% AND
				ZP2.ZP2_NUMPC = SC7.C7_NUM AND
				ZP2.ZP2_ITEMPC = SC7.C7_ITEM AND
				ZP2.ZP2_FLAGEF = 'T' AND
				ZP2.ZP2_FLAGC0 = 'F' AND
				(ZP2.ZP2_NUMPV <> %Exp:cNumPV% OR ZP2.ZP2_ITEMPV <> %Exp:cItem%)) SLDPC
		
		FROM %Table:SC7% SC7
		WHERE SC7.%NotDel% AND
			SC7.C7_FILIAL = %xFilial:SC7% AND
			SC7.C7_PRODUTO = %Exp:cProduto% AND
			SC7.C7_LOCAL = %Exp:cLocal% AND
			SC7.C7_RESIDUO = ' ' AND
			(SC7.C7_QUANT - SC7.C7_QUJE) > 0
		ORDER BY SC7.C7_DATPRF, SC7.C7_NUM
	EndSQL

	SC7TMP->(dbEval({|| IIf(SLDPC > 0,aAdd(aSaldos,{.F.,'COMPRA',0,SLDPC,SToD(C7_DATPRF),C7_NUM,C7_ITEM}),NIL)}))

	SC7TMP->(dbCloseArea())

	//-- Marca itens que já estão selecionados
	ZP2->(dbSetOrder(1))
	ZP2->(MsSeek(xFilial("ZP2")+cNumPV+cItem))
	While !ZP2->(EOF()) .And. ZP2->(ZP2_FILIAL+ZP2_NUMPV+ZP2_ITEMPV) == xFilial("ZP2")+cNumPV+cItem
		If ZP2->ZP2_FLAGEF # lEfetiva
			ZP2->(dbSkip())
			Loop
		EndIf
		If !Empty(ZP2->ZP2_NUMSC0)
			nX := 1
		Else
			If !Empty(ZP2->ZP2_NUMPC)
				nX := aScan(aSaldos,{|x| x[6]+x[7] == ZP2->(ZP2_NUMPC+ZP2_ITEMPC)})
			Else
				nX := 1
			EndIf
		EndIf
		If nX > 0
			aSaldos[nX,1] := .T.
			aSaldos[nX,3] += ZP2->ZP2_QTDE
			//		If !Empty(ZP2->ZP2_NUMSC0)
			//			SC0->(dbSetOrder(1))
			//			If SC0->(MsSeek(xFilial("SC0")+ZP2->ZP2_NUMSC0+cProduto+cLocal))
			//				aSaldos[nX,4] += SC0->C0_QTDPED
			//			EndIf
			//		EndIf
		EndIf

		ZP2->(dbSkip())
	End

	nQtdEnt := GetAdvFVal("SC6","C6_QTDENT",xFilial("SC6")+cProduto+cNumPv+cItem,2)
	nQtde	-= nQtdEnt 

	If lAutoma
		lSoma := nQtde > 0
		nX := Iif(lSoma,1,Len(aSaldos))	//-- Na soma, prioriza entregas mais próximas. Na subtração, entregas mais distantes.

		While nQtde <> 0 .And. Iif(lSoma,nX <= Len(aSaldos),nX > 0)
			If lSoma
				If (nSldDisp := aSaldos[nX,4] - aSaldos[nX,3]) > 0
					aSaldos[nX,3] += Min(nQtde,nSldDisp)	//-- Soma a quantidade a usar
					nQtde -= Min(nQtde,nSldDisp)	//-- Subtrai da variavel de controle
				EndIf
			Else
				nSldDisp := aSaldos[nX,3]
				aSaldos[nX,3] -= Min(Abs(nQtde),nSldDisp)	//-- Subtrai a quantidade devolvida
				nQtde += Min(Abs(nQtde),nSldDisp)	//-- Soma da variavel de controle
			EndIf
			aSaldos[nX,1] := aSaldos[nX,3] > 0	//-- Atualiza flag do uso

			If lSoma
				nX++
			Else
				nX--
			EndIf
		End
	Else
		DEFINE MSDIALOG oDlg TITLE "Saldos disponíveis para reserva" From 0,0 to 320,680 of oMainWnd PIXEL

		oSize := FwDefSize():New(.T.)
		oSize:AddObject("CIMA",100,10,.F.,.F.,.T.) 
		oSize:AddObject("BAIXO",100,90,.F.,.F.,.T.)
		oSize:lProp := .T.
		oSize:aMargins := {3,3,3,3} 
		oSize:Process() // Dispara os calculos

		@ oSize:GetDimension("CIMA","LININI"),oSize:GetDimension("CIMA","COLINI") SAY "Selecione os saldos a serem utilizados pela reserva:" OF oDlg PIXEL
		@ oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI") LISTBOX oList Fields HEADER "","Origem","Qtde. Usada","Qtde. Disp.","Data Dispon.","Num. PC","Item PC" SIZE 340,100;
		ON DBLCLICK (	nQtde += aSaldos[oList:nAt,3],;
		aSaldos[oList:nAt,3] := ClickManut(aSaldos[oList:nAt,1],aSaldos[oList:nAt,4],nQtde,aSaldos[oList:nAt,3]),;
		nQtde -= aSaldos[oList:nAt,3],;
		aSaldos[oList:nAt,1] := aSaldos[oList:nAt,3] > 0	) OF oDlg  PIXEL
		oList:SetArray(aSaldos)
		oList:bLine := {|| {If(aSaldos[oList:nAt,1],oOk,oNo),aSaldos[oList:nAt,2],Transform(aSaldos[oList:nAt,3],PesqPict("SB2","B2_QATU")),Transform(aSaldos[oList:nAt,4],PesqPict("SB2","B2_QATU")),DToC(aSaldos[oList:nAt,5]),aSaldos[oList:nAt,6],aSaldos[oList:nAt,7]}}

		@ oSize:GetDimension("BAIXO","LININI")+103,oSize:GetDimension("BAIXO","COLINI") SAY "Saldo a reservar: " +Transform(nQtde,PesqPict("SB2","B2_QATU")) OF oDlg PIXEL

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,	{|| lOK := .T., oDlg:End()},;
		{|| lOK := .F., oDlg:End()},.F.,aButtons,,,.F.,.F.,.F.,,.F.)
	EndIf

	If lOK
		For nX := 1 To Len(aSaldos)
			//-- Obtem recno do registro desta reserva
			If UPPER(aSaldos[nX,2]) == 'ESTOQUE'  
				BeginSQL Alias "ZP2TMP"
					SELECT COALESCE(R_E_C_N_O_,0) ZP2RECNO
					FROM %Table:ZP2%
					WHERE %NotDel% AND
					ZP2_FILIAL = %xFilial:ZP2% AND
					ZP2_NUMPV = %Exp:cNumPV% AND
					ZP2_ITEMPV = %Exp:cItem% AND
					(ZP2_NUMSC0 <> '' OR ZP2_FLAGC0 = 'T') AND
					ZP2_FLAGEF = %Exp:Iif(lEfetiva,"T","F")%
				EndSQL
			Else
				BeginSQL Alias "ZP2TMP"
					SELECT COALESCE(R_E_C_N_O_,0) ZP2RECNO
					FROM %Table:ZP2%
					WHERE %NotDel% AND
					ZP2_FILIAL = %xFilial:ZP2% AND
					ZP2_NUMPV = %Exp:cNumPV% AND
					ZP2_ITEMPV = %Exp:cItem% AND
					ZP2_NUMPC = %Exp:aSaldos[nX,6]% AND	
					ZP2_ITEMPC = %Exp:aSaldos[nX,7]% AND 
					ZP2_FLAGEF = %Exp:Iif(lEfetiva,"T","F")%
				EndSQL
			EndIf

			If !Empty(ZP2TMP->ZP2RECNO)	//-- Se reserva já tem registro, lock para alteração ou exclusão
				ZP2->(dbGoTo(ZP2TMP->ZP2RECNO))
				RecLock("ZP2",.F.)
			ElseIf aSaldos[nX,1]	//-- Se reserva não tem registro e será gerada, lock para inclusão
				RecLock("ZP2",.T.)
			EndIf

			If aSaldos[nX,1]
				ZP2->ZP2_FILIAL := xFilial("ZP2")
				ZP2->ZP2_NUMPV	:= cNumPV
				ZP2->ZP2_ITEMPV	:= cItem
				ZP2->ZP2_NUMPC	:= aSaldos[nX,6]
				ZP2->ZP2_ITEMPC	:= aSaldos[nX,7]
				ZP2->ZP2_QTDE	:= aSaldos[nX,3]
				ZP2->ZP2_DENTPV := aSaldos[nX,5]
				ZP2->ZP2_DENTPC := aSaldos[nX,5]
				ZP2->ZP2_FLAGEF := lEfetiva
				ZP2->ZP2_FLAGC0 := Empty(ZP2->ZP2_NUMPC)
				ZP2->ZP2_PRODUT := cProduto
				ZP2->ZP2_LOCAL	:= cLocal
			ElseIf !Empty(ZP2TMP->ZP2RECNO)
				ZP2->(dbDelete())
			EndIf

			ZP2->(MsUnLock())		
			ZP2TMP->(dbCloseArea())
		Next nX
	EndIf

	FillGetRes(cNumPV,cItem,lEfetiva,@oGetD)

	If !lAutoma
		SetKey(VK_F6,bBkp)
	EndIf

Return

/*/{Protheus.doc} ClickManut
// Função acionada na marcação/desmarcação de saldos disponíveis.
@author andre.oliveira
@since 09/09/2019
@version 1.0
@param lMarcou, logical, Flag que indica se a linha foi marcada ou desmarcada.
@param nQtdDisp, numeric, Quantidade disponivel na linha selecionada.
@param nQtdePV, numeric, Quantidade na proposta/pedido.
@param nQtdeMark, numeric, Quantidade já selecionada no item.
@type function
/*/
Static Function ClickManut(lMarcou,nQtdDisp,nQtdePV,nQtdeMark)
	Local nRet	:= 0
	Local lOK	:= .F.
	Local oDlg	:= NIL

	If Empty(nQtdeMark)
		nRet := Min(nQtdDisp,nQtdePV)
	Else
		nRet := nQtdeMark
	EndIf
	DEFINE MSDIALOG oDlg TITLE "" From 0,0 to 100,200 of oMainWnd PIXEL

	@ 07,05 SAY "Quantidade a reservar:" OF oDlg PIXEL
	@ 15,05 MSGET nRet Picture PesqPict("SB2","B2_QATU") Valid Positivo(nRet) .And. nRet <= nQtdDisp .And. nRet <= nQtdePV SIZE 80,15 OF oDlg PIXEL
	DEFINE SBUTTON FROM 35,05 TYPE 1 ACTION (lOK := .T.,oDlg:End()) ENABLE OF oDlg

	ACTIVATE MSDIALOG oDlg 

	If !lOK
		nRet := nQtdeMark
	EndIf

Return nRet

/*/{Protheus.doc} CalQtdSRes
// Função que calcula a quantidade do item do PV sem reserva.
@author andre.oliveira
@since 09/09/2019
@version 1.0
@return nRet, Quantidade ainda sem reserva.
@param cNumPV, characters, Número do pedido de venda.
@param cItem, characters, Item do pedido de venda.
@param nQtdPed, numeric, Quantidade do item do pedido de venda.
@param lEfetiva, logical, Reserva efetiva (PV) ou não (proposta)
@type function
/*/
Static Function CalQtdSRes(cNumPV,cItem,nQtdPed,lEfetiva)
	Local nRet	:= 0

	BeginSQL Alias "TMPZP2"
		SELECT SUM(ZP2_QTDE) TOTRES
		FROM %Table:ZP2%
		WHERE %NotDel% AND
		ZP2_FILIAL = %xFilial:ZP2% AND
		ZP2_NUMPV = %Exp:cNumPV% AND
		ZP2_ITEMPV = %Exp:cItem% AND
		ZP2_FLAGEF = %Exp:Iif(lEfetiva,"T","F")% AND
		ZP2_FLAGEX = 'F'
	EndSQL

	nRet := nQtdPed - TMPZP2->TOTRES

	TMPZP2->(dbCloseArea())

Return nRet

/*/{Protheus.doc} ResLoad2
// Função que carrega a tabela temporária (ZP2) a partir dos dados gravados em ZP1
@author andre.oliveira
@since 10/09/2019
@version 1.0
@param cNumPv, characters, Número da proposta/pedido de venda
@param lEfetiva, logical, Reserva efetiva (PV) ou não (proposta)
@type function
/*/
User Function ResLoad2(cNumPV,lEfetiva)
	Local cSQLComm	:= ""
	Local cNomesZP1	:= ""
	Local cNomesZP2	:= ""
	Local nX		:= 0
	Local nZ		:= ZP1->(FCount())

	For nX := 1 To nZ
		cNomesZP1 += ZP1->(FieldName(nX)) + IIf(nX < nZ,",","")
	Next nX
	cNomesZP1 := StrTran(cNomesZP1,",ZP1_PRODUT","")
	cNomesZP1 := StrTran(cNomesZP1,",ZP1_PRODUT,","")
	cNomesZP1 := StrTran(cNomesZP1,"ZP1_PRODUT,","")

	cNomesZP2 := StrTran(cNomesZP1,"ZP1","ZP2")

	//-- Limpa registros da ZP2
	U_ResLimZP("ZP2",cNumPV,,lEfetiva)

	//-- Copia registros da ZP1 para ZP2
	cSQLComm := "INSERT INTO " +RetSQLName("ZP2") +" (" +cNomesZP2 +", ZP2_PRODUT, ZP2_LOCAL) "
	cSQLComm += "SELECT " +cNomesZP1
	If lEfetiva 
		cSQLComm += ", SC6.C6_PRODUTO, SC6.C6_LOCAL "
	Else
		cSQLComm += ", ADZ.ADZ_PRODUT, ADZ.ADZ_LOCAL "
	EndIf
	cSQLComm += "FROM " +RetSQLName("ZP1") +" ZP1 " 
	If lEfetiva
		cSQLComm += "JOIN " +RetSQLName("SC6") +" SC6 ON "
		cSQLComm += "SC6.D_E_L_E_T_ = ' ' AND SC6.C6_FILIAL = '" +xFilial("SC6") +"' AND "
		cSQLComm += "SC6.C6_NUM = '" +cNumPV +"' AND SC6.C6_ITEM = ZP1.ZP1_ITEMPV "
	Else
		cSQLComm += "JOIN " +RetSQLName("ADZ") +" ADZ ON "
		cSQLComm += "ADZ.D_E_L_E_T_ = ' ' AND ADZ.ADZ_FILIAL = '" +xFilial("ADZ") +"' AND "
		cSQLComm += "ADZ.ADZ_PROPOS = '" +cNumPV +"' AND ADZ.ADZ_ITEM = ZP1.ZP1_ITEMPV AND "
		cSQLComm += "ADZ.ADZ_REVISA = (SELECT ADY.ADY_PREVIS FROM " +RetSQLName("ADY") +" ADY WHERE "
		cSQLComm += "ADY.D_E_L_E_T_ = ' ' AND ADY.ADY_FILIAL = '" +xFilial("ADY") +"' AND ADY.ADY_PROPOS = '" +cNumPV +"')"
	EndIf
	cSQLComm += "WHERE ZP1.D_E_L_E_T_ = ' ' AND ZP1.ZP1_FILIAL = '" +xFilial("ZP1") +"' AND "
	cSQLComm += "ZP1.ZP1_NUMPV = '" +cNumPV +"' AND ZP1.ZP1_FLAGEF = '" +Iif(lEfetiva,"T","F") +"'"
	If TCSQLExec(cSQLComm) < 0
		Aviso("Erro fatal na função ResLoad2",TCSQLError(),{"OK"},3)
		Final("Erro fatal na função ResLoad2.")
	EndIf

Return

/*/{Protheus.doc} ResGrav1
// Função responsável por:
// 1- Efetivar reservas de propostas e reavaliar disponibilidade de saldos;
// 2- Gravar reservas de propostas e pedidos na tabela ZP1 e limpar tabela temporária (ZP2).
@author andre.oliveira
@since 09/09/2019
@version 1.0
@param cNumPV, characters, Número da proposta/PV
@param lEfetiva, logical, Reserva efetiva (PV) ou não (proposta)
@param lExclui, logical, Indica se é evento de exclusão
@param cItem, logical, Item do PV (recebido somente na eliminação de residuo (processa por item).
@type function
/*/
User Function ResGrav1(cNumPV,lEfetiva,lExclui,cItem)
	Local cSQLComm	:= ""
	Local cNomesZP1	:= ""
	Local cNomesZP2	:= ""
	Local nX		:= 0
	Local nZ		:= ZP1->(FCount())
	Local aAreaADY	:= ADY->(GetArea())
	Local lOrigProp	:= .F.
	Local aAviso	:= {}

	Default cItem	:= ""

	//-- Tratamento para efetivação de proposta:
	//-- Promove registros a efetivos e atualiza vinculo para PV
	If lEfetiva .And. !lExclui //.and. IsincallStack("Ft300GPdAuto")

		/*
		SC6->(DbSetOrder(1))
		SC6->(DbSeek(xFilial("SC6")+cNumPV))
		Do While SC6->(!EOF()) .and. SC6->C6_NUM == cNumPV
		U_ResManut(SC6->C6_NUM, SC6->C6_ITEM, SC6->C6_PRODUTO, SC6->C6_LOCAL, SC6->C6_QTDVEN, .T., , .T. )
		SC6->(DbSkip())
		EndDo
		*/


		BeginSQL Alias "ZP1TMP"
			SELECT SC6.C6_NUM,
			SC6.C6_ITEM,
			ZP1.R_E_C_N_O_ ZP1RECNO
			FROM %Table:SC6% SC6
			JOIN %Table:SC5%  SC5 ON
			SC5.%NotDel% AND
			SC5.C5_FILIAL = %xFilial:SC5% AND
			SC5.C5_NUM = SC6.C6_NUM AND
			SC5.C5_ORIGEM = 'FATA300'
			JOIN %Table:SCK% SCK ON
			SCK.%NotDel% AND
			SCK.CK_FILIAL = %xFilial:SCK% AND
			SCK.CK_NUM = %Exp:SCJ->CJ_NUM% AND
			SCK.CK_ITEM = SC6.C6_ITEM AND
			SCK.CK_PRODUTO = SC6.C6_PRODUTO
			JOIN %Table:ZP1% ZP1 ON
			ZP1.%NotDel% AND
			ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
			ZP1.ZP1_NUMPV = SCK.CK_PROPOST AND
			ZP1.ZP1_ITEMPV = SCK.CK_ITEMPRO AND
			ZP1.ZP1_FLAGEF = 'F'
			WHERE SC6.%NotDel% AND
			SC6.C6_FILIAL = %xFilial:SC6% AND
			SC6.C6_NUM = %Exp:cNumPV%
		EndSQL

		While !ZP1TMP->(EOF())
			lOrigProp := .T.

			ZP1->(dbGoTo(ZP1TMP->ZP1RECNO))
			RecLock("ZP1",.F.)
			ZP1->ZP1_NUMPV	:= ZP1TMP->C6_NUM
			ZP1->ZP1_ITEMPV	:= ZP1TMP->C6_ITEM 
			ZP1->ZP1_FLAGEF := .T.
			ZP1->(MsUnLock())

			ADY->(dbSetOrder(1))
			ADY->(MsSeek(xFilial("ADY")+ZP1->ZP1_NUMPV))

			If !Empty(ADY->ADY_VEND)
				If ZP1->ZP1_FLAGEX
					ZP1->(aAdd(aAviso,{ADY->ADY_VEND,ZP1_FLAGEF,ZP1_NUMPV,ZP1_ITEMPV,"Cancelada integralmente"}))
				End
				If ZP1->ZP1_FLAGQT
					ZP1->(aAdd(aAviso,{ADY->ADY_VEND,ZP1_FLAGEF,ZP1_NUMPV,ZP1_ITEMPV,"Quantidade comprometida"}))
				EndIf
				If ZP1->(ZP1_DENTPV <> ZP1_DENTPC)
					ZP1->(aAdd(aAviso,{ADY->ADY_VEND,ZP1_FLAGEF,ZP1_NUMPV,ZP1_ITEMPV,"Data de entrega comprometida"}))
				EndIf
				If !Empty(aAviso)
					EnviaMail(aAviso)
				EndIf
			EndIf

			ZP1TMP->(dbSkip())
		End
		ZP1TMP->(dbCloseArea())

	EndIf

	//-- Gravação dos registros incluídos/editados na proposta/PV
	If !lOrigProp
		For nX := 1 To nZ
			cNomesZP1 += ZP1->(FieldName(nX)) +IIf(nX < nZ,",","")
		Next nX
		cNomesZP2 := StrTran(cNomesZP1,"ZP1","ZP2")

		//-- Antes de deletar registros antigos da ZP1, estorna reservas eliminadas por alteração do produto ou exclusão da linha
/*
		If lEfetiva
			BeginSQL Alias "SC0DEL"
				SELECT ZP1_NUMSC0
				FROM %Table:ZP1%
				WHERE %NotDel% AND
					ZP1_FILIAL = %xFilial:ZP1% AND
					ZP1_NUMPV = %Exp:cNumPV% AND
					ZP1_FLAGEF = 'T' AND
					ZP1_NUMSC0 <> ' ' AND
					ZP1_NUMSC0 NOT IN (	SELECT ZP2_NUMSC0
										FROM %Table:ZP2%
										WHERE %NotDel% AND
											ZP2_FILIAL = %xFilial:ZP2% AND
											ZP2_NUMPV = %Exp:cNumPV% AND
											ZP2_FLAGEF = 'T' AND
											ZP2_NUMSC0 <> '')
			EndSQL

			SC0->(dbSetOrder(1))
			While !SC0DEL->(EOF())
				SC0->(MsSeek(xFilial("SC0")+SC0DEL->ZP1_NUMSC0))
				//GravaB2Emp("-",SC0->C0_QUANT,"F",.T.)	//-- Necessário pois A430Reserv não volta se C0_QUANT zero.
				GravaB2Emp("+",SC0->C0_QTDPED,"F",.T.)	//-- Necessário pois A430Reserv não volta se C0_QUANT zero.
				A430Reserv({3,"PD",cNumPV,cUserName,xFilial("SC0"),""},SC0->C0_NUM,SC0->C0_PRODUTO,SC0->C0_LOCAL,SC0->C0_QUANT,{SC0->C0_NUMLOTE,SC0->C0_LOTECTL,SC0->C0_LOCALIZ,SC0->C0_NUMSERI})
	
				SC0DEL->(dbSkip())
			End
			SC0DEL->(dbCloseArea())

		EndIf
*/
		//-- Deleta registros antigos da ZP1
		U_ResLimZP("ZP1",cNumPV,,lEfetiva)

		//-- Copia ZP2 par ZP1
		If INCLUI .OR. ALTERA //alterado dia 14/02/2020 - acrescentado a regra para criar ZP1 somente com TES igual a Estoque
			If lEfetiva
				cSQLComm := "INSERT INTO " +RetSQLName("ZP1") +" (" +cNomesZP1 +") "
				cSQLComm += "SELECT " +cNomesZP2 +" FROM " +RetSQLName("ZP2") +" ZP2 " 
				cSQLComm += "JOIN " +RetSQLName("SC6") +" SC6 ON "
				cSQLComm += "SC6.D_E_L_E_T_ = ' ' AND "
				cSQLComm += "SC6.C6_FILIAL = '" +xFilial("SC6") +"' AND "
				cSQLComm += "SC6.C6_NUM = ZP2.ZP2_NUMPV AND  "
				cSQLComm += "SC6.C6_ITEM = ZP2.ZP2_ITEMPV "
				cSQLComm += "JOIN " +RetSQLName("SF4") +" SF4 ON  "
				cSQLComm += "SF4.D_E_L_E_T_ = ' ' AND "
				cSQLComm += "SF4.F4_FILIAL = '" +xFilial("SF4") +"' AND "
				cSQLComm += "SF4.F4_CODIGO = SC6.C6_TES AND "
				cSQLComm += "SF4.F4_ESTOQUE = 'S' "
				cSQLComm += "WHERE ZP2.D_E_L_E_T_ = ' ' AND " 
				cSQLComm += "ZP2.ZP2_FILIAL = '" +xFilial("ZP2") +"' AND "
				cSQLComm += "ZP2.ZP2_NUMPV = '" +cNumPV +"' AND "
				cSQLComm += "ZP2.ZP2_FLAGEF = '" +Iif(lEfetiva,"T","F") +"' AND "
				cSQLComm += "ZP2.ZP2_FLAGEX = 'F'"
			Else
				cSQLComm := "INSERT INTO " +RetSQLName("ZP1") +" (" +cNomesZP1 +") "
				cSQLComm += "SELECT " +cNomesZP2 +" FROM " +RetSQLName("ZP2") +" ZP2 " 
				cSQLComm += "JOIN " +RetSQLName("ADZ") +" ADZ ON "
				cSQLComm += "ADZ.D_E_L_E_T_ = ' ' AND "
				cSQLComm += "ZP2.ZP2_NUMPV = ADZ.ADZ_PROPOS AND  "
				cSQLComm += "ZP2.ZP2_ITEMPV = ADZ.ADZ_ITEM "
				cSQLComm += "JOIN " +RetSQLName("ADY") +" ADY ON "
				cSQLComm += "ADY.D_E_L_E_T_ = ' ' AND "
				cSQLComm += "ADY.ADY_FILIAL = '" +xFilial("ADY") +"' AND "
				cSQLComm += "ADY.ADY_PROPOS = ADZ.ADZ_PROPOS AND "
				cSQLComm += "ADY.ADY_PREVIS = ADZ.ADZ_REVISA "
				cSQLComm += "JOIN " +RetSQLName("SF4") +" SF4 ON  "
				cSQLComm += "ADZ.ADZ_TES = SF4.F4_CODIGO AND  "
				cSQLComm += "SF4.D_E_L_E_T_ = ' ' AND "
				cSQLComm += "SF4.F4_ESTOQUE = 'S' " 
				cSQLComm += "WHERE ZP2.D_E_L_E_T_ = ' ' AND " 
				cSQLComm += "ZP2.ZP2_FILIAL = '" +xFilial("ZP2") +"' AND "
				cSQLComm += "ZP2.ZP2_NUMPV = '" +cNumPV +"' AND "
				cSQLComm += "ZP2.ZP2_FLAGEF = '" +Iif(lEfetiva,"T","F") +"' AND "
				cSQLComm += "ZP2.ZP2_FLAGEX = 'F'"
			EndIf
		EndIF
		If TCSQLExec(cSQLComm) < 0
			Aviso("Erro fatal na função ResGrav1",TCSQLError(),{"OK"},3)
			Final("Erro fatal na função ResGrav1.")
		EndIf
	EndIf

	//-- Gera SC0 para reservas de estoque (primeira query para alteração a maior, segunda para a menor
	If lEfetiva .And. !lExclui
		BeginSQL Alias "ZP1SC0"
			SELECT ZP1.R_E_C_N_O_ ZP1RECNO,
			ZP1.ZP1_QTDE - COALESCE(SC0.C0_QTDPED,0) - SUM(COALESCE(SC9.C9_QTDRESE,0)) QTDGERA,
			COALESCE(SC0.C0_QTDPED,0) QTDSC0 
			FROM %Table:ZP1% ZP1
			JOIN %Table:SC6% SC6 ON
			SC6.%NotDel% AND
			SC6.C6_FILIAL = %xFilial:SC6% AND
			SC6.C6_NUM = ZP1.ZP1_NUMPV AND
			SC6.C6_ITEM = ZP1.ZP1_ITEMPV
			LEFT JOIN %Table:SC0% SC0 ON
			SC0.%NotDel% AND
			SC0.C0_FILIAL = %xFilial:SC0% AND
			SC0.C0_NUM = ZP1.ZP1_NUMSC0 AND
			SC0.C0_PRODUTO = SC6.C6_PRODUTO AND
			SC0.C0_LOCAL = SC6.C6_LOCAL
			LEFT JOIN %Table:SC9% SC9 ON
			SC9.%NotDel% AND
			SC9.C9_FILIAL = %xFilial:SC9% AND
			SC9.C9_PEDIDO = SC6.C6_NUM AND
			SC9.C9_ITEM = SC9.C9_ITEM AND
			SC9.C9_BLEST = ' ' AND
			SC9.C9_RESERVA = ZP1.ZP1_NUMSC0 
			WHERE ZP1.%NotDel% AND
			ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
			ZP1.ZP1_NUMPV = %Exp:cNumPV% AND
			ZP1.ZP1_FLAGEF = 'T' AND
			ZP1.ZP1_FLAGC0 = 'T' AND
			(ZP1.ZP1_NUMSC0 = ' ' OR ZP1.ZP1_QTDE > COALESCE(SC0.C0_QTDPED,0))
			GROUP BY ZP1.R_E_C_N_O_, ZP1.ZP1_QTDE, SC0.C0_QTDPED

			UNION

			SELECT ZP1.R_E_C_N_O_ ZP1RECNO,
			/*-SC0.C0_QUANT QTDGERA,*/ //alterado dia 19/02/2020
			ZP1.ZP1_QTDE - COALESCE(SC0.C0_QTDPED,0),			
			ZP1.ZP1_QTDE QTDSC0 
			FROM %Table:ZP1% ZP1
			JOIN %Table:SC6% SC6 ON
			SC6.%NotDel% AND
			SC6.C6_FILIAL = %xFilial:SC6% AND
			SC6.C6_NUM = ZP1.ZP1_NUMPV AND
			SC6.C6_ITEM = ZP1.ZP1_ITEMPV
			LEFT JOIN %Table:SC0% SC0 ON
			SC0.%NotDel% AND
			SC0.C0_FILIAL = %xFilial:SC0% AND
			SC0.C0_NUM = ZP1.ZP1_NUMSC0 AND
			SC0.C0_PRODUTO = SC6.C6_PRODUTO AND
			SC0.C0_LOCAL = SC6.C6_LOCAL
			WHERE ZP1.%NotDel% AND
			ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
			ZP1.ZP1_NUMPV = %Exp:cNumPV% AND
			ZP1.ZP1_FLAGEF = 'T' AND
			ZP1.ZP1_FLAGC0 = 'T' AND
			ZP1.ZP1_NUMSC0 <> ' ' AND
			(ZP1.ZP1_QTDE = SC0.C0_QTDPED OR ZP1.ZP1_QTDE < SC0.C0_QTDPED) 
		EndSQL
		While !ZP1SC0->(EOF())
			ZP1->(dbGoTo(ZP1SC0->ZP1RECNO))
			ResGrSC0(ZP1SC0->QTDGERA,ZP1SC0->QTDSC0)

			ZP1SC0->(dbSkip())
		End
		ZP1SC0->(dbCloseArea())
	EndIf

	If lEfetiva
		//-- Se exclusão de PV inteiro, exclui reservas vinculadas
		If lExclui
			cSQLComm := "%"
			If !Empty(cItem)
				cSQLComm += " ZP2.ZP2_ITEMPV = '" +cItem +"' AND "
			EndIf
			cSQLComm += "%"
			BeginSQL Alias "ZP2SC0"
				SELECT ZP2.ZP2_NUMSC0,
				SC0.C0_PRODUTO,
				SC0.C0_LOCAL,
				SC0.C0_QUANT,
				SC0.C0_LOTECTL,
				SC0.C0_NUMLOTE,
				SC0.C0_LOCALIZ,
				SC0.C0_NUMSERI
				FROM %Table:ZP2% ZP2
				JOIN %Table:SC6% SC6 ON
				SC6.C6_FILIAL = %xFilial:SC6% AND
				SC6.C6_NUM = ZP2.ZP2_NUMPV AND
				SC6.C6_ITEM = ZP2.ZP2_ITEMPV AND
				SC6.R_E_C_N_O_ = (	SELECT MAX(SC6R.R_E_C_N_O_)
				FROM %Table:SC6% SC6R 
				WHERE SC6R.C6_FILIAL = %xFilial:SC6% AND 
				SC6R.C6_NUM = ZP2.ZP2_NUMPV AND
				SC6R.C6_ITEM = ZP2.ZP2_ITEMPV	)
				JOIN %Table:SC0% SC0 ON
				SC0.%NotDel% AND
				SC0.C0_FILIAL = %xFilial:SC0% AND
				SC0.C0_NUM = ZP2.ZP2_NUMSC0 AND
				SC0.C0_PRODUTO = SC6.C6_PRODUTO AND
				SC0.C0_LOCAL = SC6.C6_LOCAL
				WHERE ZP2.%NotDel% AND
				ZP2.ZP2_FILIAL = %xFilial:ZP2% AND
				ZP2.ZP2_NUMPV = %Exp:cNumPV% AND
				%Exp:cSQLComm%
				ZP2.ZP2_FLAGEF = 'T' AND
				ZP2.ZP2_FLAGC0 = 'T'
			EndSQL
			SC0->(dbSetOrder(1))
			While !ZP2SC0->(EOF())
				SC0->(MsSeek(xFilial("SC0")+ZP2SC0->(ZP2_NUMSC0+C0_PRODUTO+C0_LOCAL)))

//				cSC0CodPro	:= SC0->C0_PRODUTO
//				nSC0QtdPed 	:= SC0->C0_QTDORIG

				A430Reserv({3,"PD",cNumPV,cUserName,xFilial("SC0"),""},ZP2SC0->ZP2_NUMSC0,ZP2SC0->C0_PRODUTO,ZP2SC0->C0_LOCAL,ZP2SC0->C0_QUANT,{ZP2SC0->C0_NUMLOTE,ZP2SC0->C0_LOTECTL,ZP2SC0->C0_LOCALIZ,ZP2SC0->C0_NUMSERI})

//				If SB2->(MsSeek(xFilial("SB2")+ZP2SC0->(C0_PRODUTO+C0_LOCAL)))
//					If SB2->B2_COD == cSC0CodPro
//						RecLock("SB2",.F.)
//						SB2->B2_QPEDVEN += nSC0QtdPed
//						SB2->(MsUnLock())
//					EndIf
//				EndIf

				ZP2SC0->(dbSkip())
			End
			ZP2SC0->(dbCloseArea())

		Else
			//-- Se alteração, exclui reserva de itens deletados ou reservas deletadas
			BeginSQL Alias "SC0DEL"
				SELECT SC0.R_E_C_N_O_ AS SC0RECNO
				FROM %Table:SC0% SC0
				WHERE SC0.%NotDel% AND
				SC0.C0_TIPO = 'PD' AND
				SC0.C0_DOCRES = %Exp:cNumPV% AND
				(NOT EXISTS (	SELECT SC6.R_E_C_N_O_
				FROM %Table:SC6% SC6
				WHERE SC6.%NotDel% AND
				SC6.C6_FILIAL = %xFilial:SC6% AND
				SC6.C6_NUM = %Exp:cNumPV% AND
				SC6.C6_RESERVA = SC0.C0_NUM AND
				SC6.C6_PRODUTO = SC0.C0_PRODUTO AND
				SC6.C6_LOCAL = SC0.C0_LOCAL	)	OR
				NOT EXISTS (	SELECT ZP1.R_E_C_N_O_
				FROM %Table:ZP1% ZP1
				WHERE ZP1.%NotDel% AND
				ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
				ZP1.ZP1_NUMPV = %Exp:cNumPV% AND
				ZP1.ZP1_FLAGEF = 'T' AND
				ZP1.ZP1_NUMSC0 = SC0.C0_NUM	)	)	
			EndSQL
			While !SC0DEL->(EOF())
				SC0->(dbGoTo(SC0DEL->SC0RECNO))

				cSC0CodPro	:= SC0->C0_PRODUTO
				nSC0QtdPed 	:= SC0->C0_QTDPED

				//-- Atualiza Pedido de Vendas limpando o campo Reserva
				cSQLComm := "UPDATE "+RetSQLName("SC6")+" " 
				cSQLComm += "SET C6_RESERVA = '', C6_QTDRESE = 0 "
				cSQLComm += "WHERE D_E_L_E_T_ = ' ' " 
				cSQLComm += "AND C6_FILIAL = '"+xFilial("SC6")+"' "
				cSQLComm += "AND C6_RESERVA = '"+SC0->C0_NUM+"' "
				cSQLComm += "AND C6_PRODUTO = '"+SC0->C0_PRODUTO+"' "
				If TCSQLExec(cSQLComm) < 0
					Aviso("Erro fatal na função ResAtuPC",TCSQLError(),{"OK"},3)
					Final("Erro fatal na função ResAtuPC.")
				EndIf

				//-- Atualiza Pedido de Vendas limpando o campo Reserva
				Reclock("SC0",.F.)
				SC0->C0_QUANT	:= SC0->C0_QTDPED 
				SC0->C0_QTDPED	:= 0
				MsUnlock()

				A430Reserv({3,"PD",cNumPV,cUserName,xFilial("SC0"),""},SC0->C0_NUM,SC0->C0_PRODUTO,SC0->C0_LOCAL,SC0->C0_QUANT,{SC0->C0_NUMLOTE,SC0->C0_LOTECTL,SC0->C0_LOCALIZ,SC0->C0_NUMSERI})

				If SB2->B2_COD == cSC0CodPro
					RecLock("SB2",.F.)
					SB2->B2_QPEDVEN += nSC0QtdPed
					SB2->(MsUnLock())
				EndIf

				SC0DEL->(dbSkip())
			End
			SC0DEL->(dbCloseArea())
		EndIf
	EndIf

	//-- Limpa registros da ZP2
	U_ResLimZP("ZP2",cNumPV,,lEfetiva)

	RestArea(aAreaADY)
Return


/*/{Protheus.doc} ResLimZP
// Função responsavel por deletar registros da ZP2 de um pedido
@author andre.oliveira
@since 16/09/2019
@version 1.0
@param cNumPV, characters, descricao
@param lEfetiva, logical, descricao
@type function
/*/
User Function ResLimZP(cAlias,cNumPV,cItem,lEfetiva)
	cSQLComm := ""

	//-- Limpa registros da ZP2
	cSQLComm := "DELETE FROM " +RetSQLName(cAlias) +" WHERE " +cAlias +"_FILIAL = '" +xFilial(cAlias) +"' AND " +cAlias +"_NUMPV = '" +cNumPV +"' AND " +cAlias +"_FLAGEF = '" +Iif(lEfetiva,"T","F") +"'"
	If !Empty(cItem)
		cSQLComm += " AND " +cAlias +"_ITEMPV = '" +cItem +"'"
	EndIf
	If TCSQLExec(cSQLComm) < 0
		Aviso("Erro fatal na função ResLimZP",TCSQLError(),{"OK"},3)
		Final("Erro fatal na função ResLimZP.")
	EndIf

Return

/*/{Protheus.doc} ResAtuPC
//Função responsável por atualizar as reservas em função da edição do PC
@author andre.oliveira
@since 09/09/2019
@version 1.0
@param cNumPC, characters, Número do pedido de compra atualizado
@param cItem, characters, Número do item do pedido de compra atualizado
@type function
/*/
User Function ResAtuPC(cNumPC,cItem)
	Local cSQLComm	:= ""
	Local cAviso 	:= "As reservas dos documentos abaixo foram afetadas pela alteração deste pedido: " +CRLF+CRLF
	Local aAviso	:= {}
	Local nSaldoPC	:= 0
	Local lMostraAv	:= .F.

	Default cItem	:= ""

	cSQLComm := "% ZP1_NUMPC = '" +cNumPC+"' "
	If !Empty(cItem)
		cSQLComm += "AND ZP1_ITEMPC = '" +cItem +"'"
	EndIf
	cSQLComm += "%"

	//-- Atualiza flag de reservas invalidadas pela exclusão do PC
	BeginSQL Alias "DIVEXC"
		SELECT ZP1.R_E_C_N_O_ ZP1RECNO,
		SC5.C5_VEND1 VENDEDOR,
		COALESCE(SC7.C7_PRODUTO,'') PRODUTOPC,
		COALESCE(SC7.C7_RESIDUO,'') RESIDUOPC,
		SC6.C6_PRODUTO PRODUTOPV
		FROM %Table:ZP1% ZP1
		JOIN %Table:SC5% SC5 ON
		SC5.%NotDel% AND
		SC5.C5_FILIAL = %xFilial:SC5% AND
		SC5.C5_NUM = ZP1.ZP1_NUMPV
		JOIN %Table:SC6% SC6 ON
		SC6.%NotDel% AND
		SC6.C6_FILIAL = %xFilial:SC6% AND
		SC6.C6_NUM = ZP1.ZP1_NUMPV AND
		SC6.C6_ITEM = ZP1.ZP1_ITEMPV
		LEFT JOIN %Table:SC7% SC7 ON
		SC7.%NotDel% AND
		SC7.C7_FILIAL = %xFilial:SC7% AND
		SC7.C7_NUM = ZP1.ZP1_NUMPC AND
		SC7.C7_ITEM = ZP1.ZP1_ITEMPC
		WHERE ZP1.%NotDel% AND
		ZP1.ZP1_FILIAL = %xFilial:ZP2% AND
		ZP1.ZP1_FLAGEF = 'T' AND
		%Exp:cSQLComm%

		UNION

		SELECT ZP1.R_E_C_N_O_ ZP1RECNO,
		ADY.ADY_VEND VENDEDOR,
		COALESCE(SC7.C7_PRODUTO,'') PRODUTOPC,
		COALESCE(SC7.C7_RESIDUO,'') RESIDUOPC,
		ADZ.ADZ_PRODUT PRODUTOPV
		FROM %Table:ZP1% ZP1
		JOIN %Table:ADY% ADY ON
		ADY.%NotDel% AND
		ADY.ADY_FILIAL = %xFilial:ADY% AND
		ADY.ADY_PROPOS = ZP1.ZP1_NUMPV
		JOIN %Table:ADZ% ADZ ON
		ADZ.%NotDel% AND
		ADZ.ADZ_FILIAL = %xFilial:ADZ% AND
		ADZ.ADZ_PROPOS = ZP1.ZP1_NUMPV AND
		ADZ.ADZ_REVISA = ADY.ADY_PREVIS AND
		ADZ.ADZ_ITEM = ZP1.ZP1_ITEMPV
		LEFT JOIN %Table:SC7% SC7 ON
		SC7.%NotDel% AND
		SC7.C7_FILIAL = %xFilial:SC7% AND
		SC7.C7_NUM = ZP1.ZP1_NUMPC AND
		SC7.C7_ITEM = ZP1.ZP1_ITEMPC
		WHERE ZP1.%NotDel% AND
		ZP1.ZP1_FILIAL = %xFilial:ZP2% AND
		ZP1.ZP1_FLAGEF = 'F' AND
		%Exp:cSQLComm%
	EndSQL
	While !DIVEXC->(EOF())
		ZP1->(dbGoTo(DIVEXC->ZP1RECNO))

		RecLock("ZP1",.F.)
		ZP1->ZP1_FLAGEX := !ZP1->ZP1_FLAGC0 .And. DIVEXC->(Empty(PRODUTOPC) .Or. PRODUTOPV <> PRODUTOPC .Or. !Empty(RESIDUOPC))
		ZP1->(MsUnLock())

		If ZP1->ZP1_FLAGEX
			cAviso += Iif(ZP1->ZP1_FLAGEF,"Pedido de venda ","Proposta comercial ") +ZP1->ZP1_NUMPV +", item " +ZP1->ZP1_ITEMPV +": cancelada integralmente." +CRLF
			If !Empty(DIVEXC->VENDEDOR)
				ZP1->(aAdd(aAviso,{DIVEXC->VENDEDOR,ZP1_FLAGEF,ZP1_NUMPV,ZP1_ITEMPV,"Cancelada integralmente"}))
			EndIf
			lMostraAv := .T.
		EndIf

		DIVEXC->(dbSkip())
	End
	DIVEXC->(dbCloseArea())

	//-- Atualiza flag de quantidade nas reservas que deixaram/voltaram a ser atendidas
	SC7->(dbSetOrder(1))
	SC7->(MsSeek(xFilial("SC7")+cNumPC+cItem))
	While !SC7->(EOF()) .And. SC7->(C7_FILIAL+C7_NUM) == xFilial("SC7")+cNumPC .And. Iif(!Empty(cItem),SC7->C7_ITEM == cItem,.T.)
		nSaldoPC := IIf(Empty(SC7->C7_RESIDUO),SC7->(C7_QUANT - C7_QUJE),0)

		BeginSQL Alias "DIVQTD"
			SELECT ZP1.R_E_C_N_O_ AS RECNO,
			SC5.C5_EMISSAO EMISSAO,
			SC5.C5_VEND1 VENDEDOR,
			ZP1.ZP1_FLAGEF
			FROM %Table:ZP1% ZP1
			JOIN %Table:SC5% SC5 ON
			SC5.%NotDel% AND
			SC5.C5_FILIAL = %xFilial:SC5% AND
			SC5.C5_NUM = ZP1.ZP1_NUMPV
			WHERE ZP1.%NotDel% AND
			ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
			ZP1.ZP1_NUMPC = %Exp:SC7->C7_NUM% AND
			ZP1.ZP1_ITEMPC = %Exp:SC7->C7_ITEM% AND
			ZP1.ZP1_FLAGEF = 'T' AND
			ZP1.ZP1_FLAGEX = 'F' AND
			ZP1.ZP1_FLAGC0 = 'F'

			UNION

			SELECT ZP1.R_E_C_N_O_ AS RECNO,
			ADY.ADY_DATA EMISSAO,
			ADY.ADY_VEND VENDEDOR,
			ZP1.ZP1_FLAGEF
			FROM %Table:ZP1% ZP1
			JOIN %Table:ADY% ADY ON
			ADY.%NotDel% AND
			ADY.ADY_FILIAL = %xFilial:ADY% AND
			ADY.ADY_PROPOS = ZP1.ZP1_NUMPV
			WHERE ZP1.%NotDel% AND
			ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
			ZP1.ZP1_NUMPC = %Exp:SC7->C7_NUM% AND
			ZP1.ZP1_ITEMPC = %Exp:SC7->C7_ITEM% AND
			ZP1.ZP1_FLAGEF = 'F' AND
			ZP1.ZP1_FLAGEX = 'F' AND
			ZP1.ZP1_FLAGC0 = 'F'

			ORDER BY ZP1_FLAGEF DESC, C5_EMISSAO
		EndSQL

		While !DIVQTD->(EOF())
			ZP1->(dbGoTo(DIVQTD->RECNO))

			nSaldoPC -= ZP1->ZP1_QTDE

			RecLock("ZP1",.F.)
			ZP1->ZP1_FLAGQT := nSaldoPC < 0
			ZP1->(MsUnLock())

			If ZP1->ZP1_FLAGQT
				cAviso += Iif(ZP1->ZP1_FLAGEF,"Pedido de venda ","Proposta comercial ") +ZP1->ZP1_NUMPV +" item " +ZP1->ZP1_ITEMPV +": quantidade comprometida." +CRLF
				If !Empty(DIVQTD->VENDEDOR)
					ZP1->(aAdd(aAviso,{DIVQTD->VENDEDOR,ZP1_FLAGEF,ZP1_NUMPV,ZP1_ITEMPV,"Quantidade comprometida"}))
				EndIf
				lMostraAv := .T.
			EndIf

			DIVQTD->(dbSkip())
		End
		DIVQTD->(dbCloseArea())

		SC7->(dbSkip())
	End

	//-- Atualiza data de entrega do PC nas reservas
	cSQLComm := "UPDATE " +RetSQLName("ZP1") +" SET ZP1_DENTPC = ("
	cSQLComm += "SELECT C7_DATPRF FROM " +RetSQLName("SC7") +" WHERE D_E_L_E_T_ = ' ' AND C7_FILIAL = '" +xFilial("SC7") +"' AND C7_NUM = ZP1_NUMPC AND C7_ITEM = ZP1_ITEMPC"
	cSQLComm += ") WHERE ZP1_FILIAL = '" +xFilial("ZP1") +"' AND ZP1_NUMPC = '" +cNumPC +"' AND ZP1_FLAGEX = 'F'" 
	If !Empty(cItem)
		cSQLComm += " AND ZP1_ITEMPC = '" +cItem +"'"
	EndIf
	If TCSQLExec(cSQLComm) < 0
		Aviso("Erro fatal na função ResAtuPC",TCSQLError(),{"OK"},3)
		Final("Erro fatal na função ResAtuPC.")
	EndIf
	//-- Envia aviso de data invalida (não processar quando for eliminação de resíduo)
	If Empty(cItem)
		ADY->(dbSetOrder(1))
		SC5->(dbSetOrder(1))
		ZP1->(dbSetOrder(2))
		ZP1->(MsSeek(xFilial("ZP1")+cNumPC))
		While !ZP1->(EOF()) .And. ZP1->(ZP1_FILIAL+ZP1_NUMPC) == xFilial("ZP1")+cNumPC
			If ZP1->(ZP1_DENTPV < ZP1_DENTPC)
				cAviso += Iif(ZP1->ZP1_FLAGEF,"Pedido de venda ","Proposta comercial") +ZP1->ZP1_NUMPV +" item " +ZP1->ZP1_ITEMPV +": data de entrega comprometida." +CRLF
				If ZP1->ZP1_FLAGEF
					ADY->(MsSeek(xFilial("ADY")+ZP1->ZP1_NUMPV))
					If !Empty(ADY->ADY_VEND)
						ZP1->(aAdd(aAviso,{ADY->ADY_VEND,ZP1_FLAGEF,ZP1_NUMPV,ZP1_ITEMPV,"Data de entrega comprometida"}))
					Endif
				Else
					SC5->(MsSeek(xFilial("SC5")+ZP1->ZP1_NUMPV))
					If !Empty(SC5->C5_VEND1)
						ZP1->(aAdd(aAviso,{SC5->C5_VEND1,ZP1_FLAGEF,ZP1_NUMPV,ZP1_ITEMPV,"Data de entrega comprometida"}))
					Endif
				EndIf

				lMostraAv := .T.
			EndIf

			ZP1->(dbSkip())
		End
	EndIf

	cAviso += CRLF +"Os vendedores responsáveis serão notificados por e-mail."
	If lMostraAv
		Aviso("Atenção",cAviso,{"OK"},2)
		EnviaMail(aAviso)
	EndIf

Return

/*/{Protheus.doc} ResDefLe
// Função reponsável por definição da legenda na tela de reservas
@author andre.oliveira
@since 12/09/2019
@version 1.0
@return cLegenda, Nome do bitmap a ser aplicado como legenda
@type function
/*/
User Function ResDefLe()
	Local cLegenda := ""

	If Select("ZP2TELA") > 0
		Do Case
			Case ZP2TELA->ZP2_FLAGEX
			cLegenda := "BR_VERMELHO"
			Case ZP2TELA->ZP2_FLAGQT
			cLegenda := "BR_LARANJA"
			Case !Empty(ZP2TELA->ZP2_NUMPC) .And. ZP2TELA->(ZP2_DENTPV <> ZP2_DENTPC)
			cLegenda := "BR_AMARELO"
			Otherwise
			cLegenda := "BR_VERDE"
		EndCase
	EndIf

Return cLegenda

/*/{Protheus.doc} FillGetRes
// Função para processar FillGetDados da tela de reservas
@author andre.oliveira
@since 12/09/2019
@version 1.0
@param cNumPV, characters, Número do pedido de venda
@param cItem, characters, Item do pedido de venda
@param lEfetiva, logical, Reserva efetiva (PV) ou não (proposta)
@type function
/*/
Static Function FillGetRes(cNumPV,cItem,lEfetiva,oGetD)
	Local cSQLComm	:= ""
	Local aCampos	:= {}
	Local nX		:= 0

	aHeader := {}
	aCols := {}
	n := 1

	aAdd(aCampos,"ZP2_NUMPV ")
	aAdd(aCampos,"ZP2_ITEMPV")
	aAdd(aCampos,"ZP2_FLAGEX")
	aAdd(aCampos,"ZP2_FLAGEF")
	aAdd(aCampos,"ZP2_FLAGQT")
	aAdd(aCampos,"ZP2_FLAGC0")

	cSQLComm := "SELECT * FROM " +RetSQLName("ZP2") +" WHERE D_E_L_E_T_ = ' ' AND ZP2_FILIAL = '" +xFilial('ZP2') +"' AND " 
	cSQLComm += "ZP2_NUMPV = '" +cNumPV +"' AND ZP2_ITEMPV = '" +cItem +"' AND ZP2_FLAGEF = '" +Iif(lEfetiva,"T","F") +"'"

	FillGetDados(2,"ZP2",1,,,,aCampos,,,cSQLComm,,,,,,,,"ZP2TELA")
	For nX := 1 To Len(aCols)
		aDel(aCols[nX],Len(aHeader)-1)
		aDel(aCols[nX],Len(aHeader)-1)
		aSize(aCols[nX],Len(aCols[nX])-2)
		If AllTrim(aCols[nX,1]) == "BR_VERMELHO"
			aTail(aCols[nX]) := .T.
		EndIf
	Next nX
	aDel(aHeader,Len(aHeader)-1)
	aDel(aHeader,Len(aHeader)-1)
	aSize(aHeader,Len(aHeader)-2)

	If ValType(oGetD) == "O"
		oGetD:ForceRefresh()
	EndIf

Return

/*/{Protheus.doc} Legenda
// Exibição da legenda de status
@author andre.oliveira
@since 13/09/2019
@version 1.0
@type function
/*/
Static Function Legenda()
	Local aCores := {}

	aAdd(aCores,{"BR_VERDE","Reserva em conformidade."})
	aAdd(aCores,{"BR_AMARELO","Data de entrega comprometida: pedido de compra alterado."})
	aAdd(aCores,{"BR_LARANJA","Quantidade comprometida: pedido de compra alterado."})
	aAdd(aCores,{"BR_VERMELHO","Cancelada integralmente: pedido de compra excluído."})

	BrwLegenda("Legenda de status","TESTE2",aCores)

Return

/*/{Protheus.doc} TudoOK
// Função para validação do fechamento da tela de reservas
@author andre.oliveira
@since 13/09/2019
@version 1.0
@return lRet, Indica se a tela pode ser encerrada
@param lSalva, logical, Indica se clicou em salvar (.T.) ou cancelar (.F.)
@param cNumPV, characters, Número do pedido/proposta
@param cItem, characters, Item do pedido/proposta
@param nQtdPed, numeric, Quantidade no item do pedido de venda
@param lEfetiva, logical, Indica se é PV (.T.) ou proposta (.F.)
@type function
/*/
Static Function TudoOK(lSalva,cNumPV,cItem,cProduto,cLocal,nQtdPed,lEfetiva,oGetD,aHeadBKP,aColsBKP,nNBkp,lRetTela)
	Local lRet		:= .T.
	Local nQtdSRes	:= CalQtdSRes(cNumPV,cItem,nQtdPed,lEfetiva)

	If nQtdSRes < 0
		If Aviso("Revisar reservas","A quantidade reservada é maior que a quantidade para venda. O que deseja fazer?",{"Ajustar item","Editar reservas"},1) == 2
			U_ResManut(cNumPV,cItem,cProduto,cLocal,nQtdSRes,lEfetiva,@oGetD,.F.)
			lRet := .F.
		Else
			lRetTela := .F.
		EndIf
	Endif

Return lRet

/*/{Protheus.doc} ResGrSC0
// Função que gera reserva de estoque (SC0) para ZP1 posicionada
@author andre.oliveira
@since 14/09/2019
@version 1.0
@param nQtdGera, numeric, Quantidade para gerar/somar na reserva SC0
@type function
/*/
Static Function ResGrSC0(nQtdGera,nQtdSC0)
	Local xEstoque	:= NIL
	Local nX		:= 0
	Local nOpc		:= 0
	Local nQtdJaLib	:= 0
	Local aGeraSC0	:= {}
	Local cSC0Num	:= ""

	SC0->(dbSetOrder(1))			
	SC6->(dbSetOrder(1))
	SC6->(MsSeek(xFilial("SC6")+ZP1->(ZP1_NUMPV+ZP1_ITEMPV)))
	SB2->(dbSetOrder(1))
	SB2->(MsSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL)))

	If !Empty(SC6->C6_RESERVA) //-- Alteração
		nOpc := 2
		cSC0Num := SC6->C6_RESERVA
	Else	//-- Inclusao
		nOpc :=  1
		cSC0Num := GetSXENum("SC0","C0_NUM")

		//-- Tratamento para inclusao de PV quando houver digitacao do campo C9_QTDLIB
		//-- Neste cenario gerara reserva já baixada
		SC9->(dbSetOrder(1))
		If SC9->(MsSeek(xFilial("SC9")+SC6->(C6_NUM+C6_ITEM)))
			While !SC9->(EOF()) .And. SC9->(C9_FILIAL+C9_PEDIDO+C9_ITEM) == xFilial("SC9")+SC6->(C6_NUM+C6_ITEM)
				If Empty(SC9->C9_RESERVA) .and. Empty(SC9->C9_NFISCAL) .and. Empty(SC9->C9_BLEST)	//-- Liberação sem reserva, entao gera reserva ja baixada
					nQtdJaLib += SC9->C9_QTDLIB

					RecLock("SC9",.F.)
					SC9->C9_RESERVA := cSC0Num
					SC9->C9_QTDRESE := SC9->C9_QTDLIB
					SC9->(MsUnLock())
				EndIf

				SC9->(dbSkip())
			End

			If nQtdJaLib > 0
				RecLock("SC0",.T.)
				SC0->C0_FILIAL	:= xFilial("SC0")
				SC0->C0_NUM		:= cSC0Num
				SC0->C0_TIPO	:= "LB"
				SC0->C0_DOCRES	:= SC6->C6_NUM
				SC0->C0_SOLICIT	:= cUserName
				SC0->C0_FILRES	:= xFilial("SC0")
				SC0->C0_PRODUTO	:= SC6->C6_PRODUTO
				SC0->C0_LOCAL	:= SC6->C6_LOCAL
				SC0->C0_QUANT	:= 0
				SC0->C0_VALIDA	:= dDataBase + SuperGetMV("MV_PZRESER",.F.,10)
				SC0->C0_EMISSAO := dDataBase
				SC0->C0_QTDORIG	:= nQtdJaLib
				SC0->(MsUnLock())

				ConfirmSx8()

				RecLock("ZP1",.F.)
				ZP1->ZP1_NUMSC0 := cSC0Num
				ZP1->ZP1_FLAGC0 := .T.
				ZP1->ZP1_QTDSC0 += nQtdJaLib
				ZP1->(MsUnLock())

				RecLock("SC6",.F.)
				SC6->C6_RESERVA := SC0->C0_NUM
				SC6->C6_QTDRESE := 0
				SC6->(MsUnLock())

				//-- Tratará a sobra (se houver) como alteração
				nQtdGera -= nQtdJaLib
				nOpc := 2
			EndIf
		EndIf
	EndIf

	If nQtdGera > 0	//-- Quantidade a somar
		//-- Obtém saldos para reserva
		If Rastro(SB2->B2_COD)
			/*xEstoque := aSldPorLote(SB2->B2_COD,SB2->B2_LOCAL,ZP1->ZP1_QTDE)
			For nX := 1 To Len(xEstoque)
			aAdd(aGeraSC0,{cSC0Num,SB2->B2_COD,xEstoque[nX,11],Min(xEstoque[nX,5],nQtdGera),{xEstoque[nX,2],xEstoque[nX,1],xEstoque[nX,3],xEstoque[nX,4]}})
			nQtdGera -= aTail(aGeraSC0)[4]
			Next nX*/				
		ElseIf Localiza(SB2->B2_COD)
			/*xEstoque := NIL*/
		ElseIf (xEstoque := SaldoSB2(.T.) + nQtdJaLib) > 0
			aAdd(aGeraSC0,{cSC0Num,SB2->B2_COD,SB2->B2_LOCAL,Min(xEstoque,nQtdGera),{CriaVar("C0_NUMLOTE",.F.),CriaVar("C0_LOTECTL",.F.),CriaVar("C0_LOCALIZ",.F.),CriaVar("C0_NUMSERI",.F.)}})
			nQtdGera -= aTail(aGeraSC0)[4]
		EndIf

		If !Empty(aGeraSC0)	//-- Gera as reservas e vincula ZP1 e SC6
			For nX := 1 To Len(aGeraSC0)
				If !A430Reserv({nOpc,"PD",SC6->C6_NUM,cUserName,xFilial("SC0"),""},aGeraSC0[nX,1],aGeraSC0[nX,2],aGeraSC0[nX,3],aGeraSC0[nX,4],aGeraSC0[nX,5])
					nQtdGera += aGeraSC0[nX,4]
					RollBackSX8()
				Else
					ConfirmSx8()

					RecLock("ZP1",.F.)
					ZP1->ZP1_NUMSC0 := aGeraSC0[nX,1]
					ZP1->ZP1_FLAGC0 := .T.
					ZP1->ZP1_QTDSC0 += aGeraSC0[nX,4]
					ZP1->(MsUnLock())

					SC0->(MsSeek(xFilial("SC0")+aGeraSC0[nX,1]+aGeraSC0[nX,2]+aGeraSC0[nX,3]))
					RecLock("SC0",.F.)
					SC0->C0_QUANT := 0
					SC0->C0_QTDPED += aGeraSC0[nX,4]
					SC0->(MsUnLock())

					RecLock("SC6",.F.)
					SC6->C6_RESERVA := SC0->C0_NUM
					SC6->C6_QTDRESE := SC0->C0_QTDPED
					SC6->(MsUnLock())

					RecLock("SB2",.F.)
					SB2->B2_QPEDVEN -= aGeraSC0[nX,4]
					SB2->(MsUnLock())
				EndIf
			Next nX
		EndIf

		If nQtdGera > 0
			RecLock("ZP1",.F.)
			ZP1->ZP1_FLAGQT := .T.
			ZP1->(MsUnLock())
		EndIf
	ElseIf nQtdGera < 0	//-- Quantidade a subtrair
		RecLock("ZP1",.F.)
		ZP1->ZP1_QTDSC0 += nQtdGera
		If ZP1->ZP1_QTDSC0 == 0
			ZP1->ZP1_NUMSC0 := ''
			Zp1->ZP1_FLAGC0 := .F.
		EndIf 
		ZP1->(MsUnLock())

		SC0->(MsSeek(xFilial("SC0")+cSC0Num+SC6->(C6_PRODUTO+C6_LOCAL)))
		RecLock("SC0",.F.)
		SC0->C0_QUANT := 0
		SC0->C0_QTDPED := nQtdSC0
		SC0->(MsUnLock())

		RecLock("SC6",.F.)
		SC6->C6_QTDRESE := nQtdSC0
		SC6->(MsUnLock())

		GravaB2Emp("-",Abs(nQtdGera),"F",.T.)

		RecLock("SB2",.F.)
		SB2->B2_QPEDVEN += Abs(nQtdGera)
		SB2->(MsUnLock())

		nQtdGera := 0
	EndIf

Return nQtdGera

/*/{Protheus.doc} RetSC0NGrv
// Função que retorna a quantidade reservada (indisponivel) mas ainda não gravada.
@author andre.oliveira
@since 16/09/2019
@version 1.0
@return nRet, Quantidade indisponivel
@param cNumPV, characters, Número do pedido de venda
@param cItem, characters, Item do pedido de venda
@param cProduto, characters, Código do produto
@param cLocal, characters, Código do local
@type function
/*/
Static Function RetSC0NGrv(cNumPV,cItem,cProduto,cLocal,lEfetiva)
	Local nRet:= 0

	BeginSQL Alias "SC0ZP2"
		SELECT COALESCE(SUM(ZP2.ZP2_QTDE),0) - (SUM(COALESCE(SC0.C0_QTDPED,0)) + SUM(COALESCE(SC9.C9_QTDRESE,0))) ZP2_QTDE
		FROM %Table:ZP2% ZP2
		LEFT JOIN %Table:SC0% SC0 ON
		SC0.%NotDel% AND
		SC0.C0_FILIAL = %xFilial:SC0% AND
		SC0.C0_NUM = ZP2.ZP2_NUMSC0 AND
		SC0.C0_PRODUTO = %Exp:cProduto% AND
		SC0.C0_LOCAL = %Exp:cLocal%
		LEFT JOIN %Table:SC9% SC9 ON
		SC9.%NotDel% AND
		SC9.C9_FILIAL = %xFilial:SC9% AND
		SC9.C9_PEDIDO = ZP2.ZP2_NUMPV AND
		SC9.C9_ITEM = ZP2.ZP2_ITEMPV AND
		SC9.C9_BLEST = ' '	
		WHERE ZP2.%NotDel% AND
		ZP2.ZP2_FILIAL = %xFilial:ZP2% AND
		ZP2.ZP2_NUMPV||ZP2.ZP2_ITEMPV <> %Exp:Iif(lEfetiva,cNumPV+cItem,"")% AND
		ZP2.ZP2_FLAGEF = 'T' AND
		ZP2.ZP2_FLAGC0 = 'T' AND
		(ZP2.ZP2_NUMSC0 = ' ' OR ZP2.ZP2_QTDE > COALESCE(SC0.C0_QTDPED,0)) AND
		ZP2.ZP2_PRODUT = %Exp:cProduto% AND
		ZP2.ZP2_LOCAL = %Exp:cLocal%
	EndSQL
	nRet := SC0ZP2->ZP2_QTDE
	SC0ZP2->(dbCloseArea())

Return nRet

/*/{Protheus.doc} ResEvNFE
// Função responsável pele geração de SC0 na inclusão da nota
@author andre.oliveira
@since 16/09/2019
@version 1.0
@param nEvento, numeric, Identificado do evento (1=Inclusão;2=Exclusão)
@param cDoc, characters, Documento (número da nota)
@param cSerie, characters, Série da nota
@param cFornece, characters, Código do fornecedor
@param cLoja, characters, Código da loja do fornecedor
@param cProduto, characters, Código do produto
@param cItem, characters, Item da nota fiscal
@type function
/*/
User Function ResEvNFE(nEvento,cDoc,cSerie,cFornece,cLoja,cProduto,cItem)
	Local nQtdGera	:= 0
	Local nQtdSC0	:= 0
	Local nSaldoSD1	:= 0
	Local nX		:= 0
	Local nQtdSC0Us := 0
	Local aSC0Acum	:= {}
	Local cOrder	:= "%ORDER BY C5_EMISSAO " +IIf(nEvento == 1,'ASC','DESC') +"%"

	If Empty(SD1->D1_TRANSIT)	//-- Notas em trânsito são processadas somente após chegada do trânsito
		If SF4->F4_ESTOQUE == 'S' .And. !Empty(SD1->(D1_PEDIDO+D1_ITEMPC))
			SD1->(dbSetOrder(1))
			SD1->(MsSeek(xFilial("SD1")+cDoc+cSerie+cFornece+cLoja+cProduto+cItem))
			SF4->(dbSetOrder(1))
			SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))

			nSaldoSD1 := SD1->D1_QUANT

			BeginSQL Alias "ZP1SC0"
				SELECT ZP1.R_E_C_N_O_ ZP1RECNO,
				ZP1.ZP1_QTDE,
				COALESCE(SC0.C0_QTDPED,0) + COALESCE(SUM(SC9.C9_QTDRESE),0) C0_QTDPED,
				SC0.C0_PRODUTO,
				SC0.C0_LOCAL
				FROM %Table:ZP1% ZP1
				JOIN %Table:SC5% SC5 ON
				SC5.%NotDel% AND
				SC5.C5_FILIAL = %xFilial:SC5% AND
				SC5.C5_NUM = ZP1.ZP1_NUMPV 
				LEFT JOIN %Table:SC0% SC0 ON
				SC0.%NotDel% AND
				SC0.C0_FILIAL = %xFilial:SC0% AND
				SC0.C0_NUM = ZP1.ZP1_NUMSC0
				LEFT JOIN %Table:SC9% SC9 ON
				SC9.%NotDel% AND
				SC9.C9_FILIAL = %xFilial:SC9% AND
				SC9.C9_PEDIDO = ZP1.ZP1_NUMPV AND
				SC9.C9_ITEM = ZP1.ZP1_ITEMPV AND
				SC9.C9_BLEST = ' '
				WHERE ZP1.%NotDel% AND
				ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
				ZP1.ZP1_NUMPC = %Exp:SD1->D1_PEDIDO% AND
				ZP1.ZP1_ITEMPC = %Exp:SD1->D1_ITEMPC% AND
				1 = 1
				GROUP BY ZP1.R_E_C_N_O_, ZP1.ZP1_QTDE, SC0.C0_QTDPED, SC0.C0_PRODUTO, SC0.C0_LOCAL, SC5.C5_EMISSAO
				%Exp:cOrder%
			EndSQL
			While !ZP1SC0->(EOF()) .And. nSaldoSD1 > 0
				ZP1->(dbGoTo(ZP1SC0->ZP1RECNO))

				RecLock("ZP1",.F.)
				If nEvento == 1 .Or. ZP1SC0->C0_QTDPED > nSaldoSD1	//-- Na exclusão, se reserva maior que nota, não exclui SC0 
					ZP1->ZP1_FLAGC0 := .T.
				Else
					ZP1->ZP1_FLAGC0 := .F.
				EndIf
				ZP1->(MsUnLock())

				If ZP1->ZP1_FLAGEF //-- Se reserva efetiva, gera SC0
					SC6->(dbSetOrder(1))
					SC6->(MsSeek(xFilial("SC6")+ZP1->(ZP1_NUMPV+ZP1_ITEMPV)))

					If nEvento == 1		//-- Inclusão
						//-- Tratamento para ignorar as reservas já atendidas na integridade (em notas anteriores)
						//-- E reservas parcialmente atendidas (array aSC0Acum controlará a quantidade usada de cada SC0)
						If (nX := aScan(aSC0Acum,{|x| x[1] == ZP1->ZP1_NUMSC0})) > 0
							nQtdSC0Us := aSC0Acum[nX,2]
						EndIf
						If ZP1SC0->(ZP1_QTDE <= (C0_QTDPED - nQtdSC0Us))
							If nX == 0
								aAdd(aSC0Acum,{ZP1->ZP1_NUMSC0,ZP1->ZP1_QTDE})
							Else
								aSC0Acum[nX,2] += ZP1->ZP1_QTDE
							EndIf
							ZP1SC0->(dbSkip())
							Loop
						EndIf

						nQtdGera := Min(ZP1SC0->ZP1_QTDE - (ZP1SC0->C0_QTDPED - nQtdSC0Us),nSaldoSD1)
						nQtdSC0 := ZP1SC0->C0_QTDPED
						nSaldoSD1 -= nQtdGera
						nSaldoSD1 += ResGrSC0(nQtdGera,nQtdSC0) //-- Soma pro caso de não ter gerado SC0 
					ElseIf ZP1SC0->C0_QTDPED > nSaldoSD1	//-- Exclusão e reserva maior que nota: altera reduzindo quantidade
						nQtdGera := -nSaldoSD1
						nSaldoSD1 -= Abs(nQtdGera)
						nSaldoSD1 += ResGrSC0(nQtdGera,ZP1SC0->C0_QTDPED - Abs(nQtdGera)) //-- Soma pro caso de não ter alterado SC0
					Else	//-- Exclusão e reserva menor/igual a nota: exclui reserva
						SC0->(MsSeek(xFilial("SC0")+ZP1->ZP1_NUMSC0+ZP1SC0->(C0_PRODUTO+C0_LOCAL)))
						nQtdGera := SC0->C0_QTDPED
						If A430Reserv({3,"PD",ZP1->ZP1_NUMPV,cUserName,xFilial("SC0"),""},SC0->C0_NUM,SC0->C0_PRODUTO,SC0->C0_LOCAL,SC0->C0_QUANT,{SC0->C0_NUMLOTE,SC0->C0_LOTECTL,SC0->C0_LOCALIZ,SC0->C0_NUMSERI})
							nSaldoSD1 -= nQtdGera
							GravaB2Emp("-",nQtdGera,"F",.T.)	//-- Necessário pois A430Reserv não volta se C0_QUANT zero.

							RecLock("ZP1",.F.)
							ZP1->ZP1_QTDSC0 := 0
							ZP1->ZP1_NUMSC0 := ''
							ZP1->(MsUnLock())

							RecLock("SC6",.F.)
							SC6->C6_RESERVA := ''
							SC6->C6_QTDRESE := 0
							SC6->(MsUnLock())
						ElseIf !Empty(ZP1->ZP1_NUMSC0) //-- Volta flag
							RecLock("ZP1",.F.)
							ZP1->ZP1_FLAGC0 := .T.
							ZP1->(MsUnLock())
						EndIf
					EndIf
				EndIf

				ZP1SC0->(dbSkip())
			End
			ZP1SC0->(dbCloseArea())
		EndIf
	EndIf

Return

/*/{Protheus.doc} ResVlAlt
// Função que valida a exclusão de linha e a alteração de dados chave
// de linha com reserva 
@author andre.oliveira
@since 17/09/2019
@version 1.0
@return lRet, Indica se permite a operação ou se aborta
@param nEvento, numeric, Identificador do evento (1-delete da linha; 2-alteração de campo
@param cCampo, characters, Identificador do campo alterado
@param lEfetiva, logical, Identifica se é PV ou proposta
@type function
/*/
User Function ResVlAlt(nEvento,cCampo,lEfetiva)
	Local lRet		:= .T.
	Local lDeleta	:= .F.
	Local cNumPV	:= Iif(lEfetiva,M->C5_NUM,FWFldGet("ADY_PROPOS"))
	Local cItem		:= Iif(lEfetiva,aCols[n,GDFieldPos("C6_ITEM")],FWFldGet("ADZ_ITEM"))
	Local cAlias	:= Iif(lEfetiva,"SC6","ADZ")

	BeginSQL Alias "ZP2TMP"
		SELECT COALESCE(R_E_C_N_O_,0) ZP2RECNO
		FROM %Table:ZP2%
		WHERE %NotDel% AND
		ZP2_FILIAL = %xFilial:ZP2% AND
		ZP2_NUMPV = %Exp:cNumPV% AND
		ZP2_ITEMPV = %Exp:cItem% AND
		ZP2_FLAGEF = %Exp:Iif(lEfetiva,"T","F")%
	EndSQL

	(cAlias)->(dbSetOrder(1))
	(cAlias)->(MsSeek(xFilial(cAlias)+cNumPV+cItem))
	If !Empty(ZP2TMP->ZP2RECNO)
		//-- Exclusão de linha e item com reserva
		If nEvento == 1
			If Aviso("Item com reserva(s)","Este item possui reserva(s) relacionada(s) e ao excluí-lo suas reservas serão perdidas. Confirma exclusão?",{"Não","Sim"}) == 2
				lDeleta := .T.
			Else
				lRet := .F.
			EndIf

			//-- Alteração de campo
		ElseIf nEvento == 2
			If lEfetiva
				cCampo := Right(cAlias+cCampo,10)
				lRet := M->&(cCampo) == (cAlias)->&(cCampo)
			Else
				cCampo := Left(cAlias+cCampo,10)
				lRet := FWFldGet(cCampo) == (cAlias)->&(cCampo)
			EndIf
			If !lRet .And. Aviso("Item com reserva(s)","Este item possui reserva(s) relacionada(s) e ao alterar este campo suas reservas serão perdidas. Confirma alteração?",{"Não","Sim"}) == 2
				lDeleta := .T.
				lRet := .T.
			EndIf
		EndIf

		If lDeleta
			U_ResLimZP("ZP2",cNumPV,cItem,lEfetiva)
			If lEfetiva
				aCols[n,GdFieldPos("C6_RESERVA")] := CriaVar("C6_RESERVA",.F.)
			EndIf
		EndIf
	EndIf
	ZP2TMP->(dbCloseArea())

	If lEfetiva .And. !lRet
		Help(" ",1,"UNDO",,"Operação cancelada.",4,0)
	EndIf

Return lRet

/*/{Protheus.doc} ResRemC0
// Função que desvincula SC0 da SC6, para permitir eliminação de residuo do PV
@author andre.oliveira
@since 24/09/2019
@version 1.0
@param cNumPV, characters, Numero do pedido de venda
@param cItem, characters, Item do pedido de venda
@type function
/*/
User Function ResRemC0(cNumPV,cItem)
	Default cItem := ""

	SC0->(dbSetOrder(1))
	SC6->(dbSetOrder(1))
	SC6->(MsSeek(xFilial("SC6")+cNumPV+cItem))
	While !SC6->(EOF()) .And. SC6->(C6_FILIAL+C6_NUM) == xFilial("SC6")+cNumPV .And. Iif(!Empty(cItem), SC6->C6_ITEM == cItem,.T.)
		If !Empty(SC6->C6_RESERVA) .And. SC0->(MsSeek(xFilial("SC0")+SC6->(C6_RESERVA+C6_PRODUTO+C6_LOCAL)))
			RecLock("SC0",.F.)
			SC0->C0_QUANT += SC6->C6_QTDRESE
			SC0->C0_QTDPED -= SC6->C6_QTDRESE
			SC0->(MsUnLock())

			RecLock("SC6",.F.)
			SC6->C6_RESERVA := ""
			SC6->C6_QTDRESE := 0
			SC6->(MsUnLock())
		EndIf

		SC6->(dbSkip())
	End 

Return

/*/{Protheus.doc} ResPVEli
// Função responsável por excluir reservas (se processado)
// ou restaurar reservas (se nao processado) após
// eliminação de resíduos
@author andre.oliveira
@since 24/09/2019
@version 1.0
@param cNumPV, characters, Número do pedido de venda
@param cItem, characters, Item do pedido de venda
@param lEliminou, logical, Flag que indica se eliminou resíduo ou não
@type function
/*/
User Function ResPVEli(cNumPV,cItem,lEliminou)

	If lEliminou	//-- Se eliminou residuo, processa exclusão de reservas
		U_ResGrav1(cNumPV,.T.,.T.,cItem)
	Else	//-- Se não eliminou residuo, refaz vínculo com a reserva
		SC0->(dbSetOrder(1))
		ZP1->(dbSetOrder(1))
		If ZP1->(MsSeek(xFilial("ZP1")+cNumPV+cItem)) .And. !Empty(ZP1->ZP1_NUMSC0)
			SC6->(dbSetOrder(1))
			SC6->(MsSeek(xFilial("SC6")+cNumPv+cItem))
			If SC0->(MsSeek(xFilial("SC0")+ZP1->ZP1_NUMSC0+SC6->(C6_PRODUTO+C6_LOCAL)))
				RecLock("SC6",.F.)
				SC6->C6_RESERVA := SC0->C0_NUM
				SC6->C6_QTDRESE := Min(ZP1->ZP1_QTDE,SC0->C0_QUANT)
				SC6->(MsUnLock())

				RecLock("SC0",.F.)
				SC0->C0_QUANT -= SC6->C6_QTDRESE
				SC0->C0_QTDPED += SC6->C6_QTDRESE
				SC0->(MsUnLock())
			EndIf
		EndIf
	EndIf
Return

/*/{Protheus.doc} VisualPC
// Função para visualizar PC
@author andre.oliveira
@since 24/09/2019
@version 1.0
@param cNumPC, characters, Numero do PC
@type function
/*/
Static Function VisualDet(cProduto,cNumPC)
	Local aHeadBkp	:= aClone(aHeader)
	Local aColsBkp	:= aClone(aCols)
	Local nNBkp 	:= n
	Local bBkp		:= SetKey(VK_F6,NIL)
	Local aRotBkp	:= aClone(aRotina) 

	If Empty(cNumPC)
		MaViewSB2(cProduto)
	Else
		SC7->(dbSetOrder(1))
		SC7->(MsSeek(xFilial("SC7")+cNumPC))
		If (nTipoPed := SC7->C7_TIPO) == 1
			aRotina := StaticCall(MATA121,MenuDef)
		Else
			aRotina := StaticCall(MATA122,MenuDef)
		EndIf	
		A120Pedido("SC7",SC7->(Recno()),2)

		aHeader := aClone(aHeadBkp)
		aCols := aClone(aColsBkp)
		n := nNBkp
		aRotina := aClone(aRotBkp)
	EndIf

	SetKey(VK_F6,bBkp)

Return

/*/{Protheus.doc} EnviaMail
// Função responsável pelo envio do e-mail de aviso de reservas afetadas
@author andre.oliveira
@since 09/10/2019
@version 1.0
@param aAviso, array, Array com as informaçõe de envio
@type function
/*/
Static Function EnviaMail(aAviso)
	Local nX		:= 1
	Local cHTMLSrc	:= "/samples/resaviso.html"
	Local cHTMLDst	:= "/samples/"+GetNextAlias()+".htm"
	Local cQuebra	:= ""
	Local oHTMLBody	:= Nil

	//-- Identifica vendedores
	aSort(aAviso,,,{|x,y| y[1] < x[1]})
	SA3->(dbSetOrder(1))

	While !Empty(aAviso)
		If nX > Len(aAviso) .Or. cQuebra <> aAviso[nX,1]
			If !Empty(cQuebra)	
				oHTMLBody:SaveFile(cHTMLDst)
				SA3->(MsSeek(xFilial("SA3")+cQuebra))
				MTSendMail({AllTrim(SA3->A3_EMAIL)},"[AGRU] Ocorrências em reservas",DecodeUTF8(MtHTML2Str(cHTMLDst)))
				FErase(cHTMLDst)

				If nX > Len(aAviso)
					Exit
				EndIf
			EndIf

			oHTMLBody:= TWFHTML():New(cHTMLSrc)
			cQuebra := aAviso[nX,1]
		EndIf

		While nX <= Len(aAviso) .And. cQuebra == aAviso[nX,1]
			aAdd(oHTMLBody:ValByName('It.cTipo'),If(aAviso[nX,2],"Pedido de venda","Proposta comercial"))
			aAdd(oHTMLBody:ValByName('It.cNumero'),aAviso[nX,3])
			aAdd(oHTMLBody:ValByName('It.cItem'),aAviso[nX,4])
			aAdd(oHTMLBody:ValByName('It.cOcorrencia'),aAviso[nX,5])
			nX++
		End
	End

Return

/*/{Protheus.doc} ResQuant
// Função que retorna o total de reservas efetivas de um produto
@author andre.oliveira
@since 10/10/2019
@version 1.0
@return nRet, Quantidade em reservas (ZP1 e ZP2)
@param cProduto, characters, descricao
@param cLocal, characters, descricao
@type function
/*/
User Function ResQuant(cProduto,cLocal)
	Local nRet := 0

	//-- Soma reservas da ZP1
	//--SELECT COALESCE(SUM(ZP1.ZP1_QTDE),0) - COALESCE(SUM(SC0.C0_QTDPED),0) - SUM(COALESCE(SC9.C9_QTDLIB,0)) - SUM(SC6.C6_QTDENT) RESERVAS
	BeginSQL Alias "TOTZP1"
		SELECT COALESCE(SUM(ZP1.ZP1_QTDE - ZP1.ZP1_QTDSC0),0) RESERVAS
		FROM %Table:ZP1% ZP1
		JOIN %Table:SC6% SC6 ON
		SC6.%NotDel% AND
		SC6.C6_FILIAL = %xFilial:SC6% AND
		SC6.C6_NUM = ZP1.ZP1_NUMPV AND
		SC6.C6_ITEM = ZP1.ZP1_ITEMPV AND
		SC6.C6_PRODUTO = %Exp:cProduto% AND
		SC6.C6_LOCAL = %Exp:cLocal%
		LEFT JOIN %Table:SC0% SC0 ON
		SC0.%NotDel% AND
		SC0.C0_FILIAL = %xFilial:SC0% AND
		SC0.C0_NUM = ZP1.ZP1_NUMSC0 AND
		SC0.C0_PRODUTO = %Exp:cProduto% AND
		SC0.C0_LOCAL = %Exp:cLocal%
		LEFT JOIN %Table:SC9% SC9 ON
		SC9.%NotDel% AND
		SC9.C9_FILIAL = %xFilial:SC9% AND
		SC9.C9_PEDIDO = SC6.C6_NUM AND
		SC9.C9_ITEM = SC6.C6_ITEM AND
		SC9.C9_BLEST = ' '
		WHERE ZP1.%NotDel% AND
		ZP1.ZP1_FILIAL = %xFilial:ZP1% AND
		ZP1.ZP1_FLAGEF = 'T' AND
		ZP1.ZP1_FLAGQT <> 'T' //alterado dia 04/02/2020

	EndSQL
	nRet += TOTZP1->RESERVAS
	TOTZP1->(dbCloseArea())

Return nRet

/*/{Protheus.doc} RetSC0Item
//Função responsável por calcular a quantidade reservada em SC0 e SC9 para um item de pedido de venda
@author andre.oliveira
@since 06/12/2019
@version 1.0
@return nREt, Quantidade reservada na SC0
@param cNumPV, characters, Numero do pedido de venda
@param cItem, characters, Item do pedido de venda
@type function
/*/
Static Function RetSC0Item(cNumPV,cItem)
	Local nRet := 0

	BeginSQL Alias "TMPZP1"
		SELECT SUM(ZP1_QTDSC0) ZP1_QTDSC0
		FROM %Table:ZP1%
		WHERE %NotDel% AND
		ZP1_FILIAL = %xFilial:ZP1% AND
		ZP1_NUMPV = %Exp:cNumPV% AND
		ZP1_ITEMPV = %Exp:cItem% AND
		ZP1_FLAGEF = 'T' AND
		ZP1_FLAGC0 = 'T' AND
		ZP1_NUMSC0 <> ' '
	EndSQL
	nRet := TMPZP1->ZP1_QTDSC0
	TMPZP1->(dbCloseArea())

	BeginSQL Alias "TMPSC9"
		SELECT SUM(C9_QTDLIB - C9_QTDRESE) C9_QTDLIB
		FROM %Table:SC9%
		WHERE %NotDel% AND
		C9_FILIAL = %xFilial:SC9% AND
		C9_PEDIDO = %Exp:cNumPV% AND
		C9_ITEM = %Exp:cItem% AND
		C9_BLEST = ' '
	EndSQL
	nRet += TMPSC9->C9_QTDLIB
	TMPSC9->(dbCloseArea())

Return nRet